// TODO add client itself as connection maybe over a const u64 identifier or alternativly its own steamid?

use std::{collections::HashMap, time::Duration};

use renet::RenetServer;
use steamworks::{
    networking_sockets::{ListenSocket, NetConnection},
    networking_types::NetworkingConfigEntry,
    Client, ClientManager, SteamId,
};

pub struct SteamTransportConfig {
    max_clients: usize,
}

pub struct Server<Manager = Client> {
    listen_socket: ListenSocket<Manager>,
    config: SteamTransportConfig,
    connections: HashMap<u64, NetConnection<Manager>>,
    connections_steam_id: HashMap<SteamId, u64>,
}

trait Transport {
    fn update(&mut self, duration: Duration, server: &mut RenetServer);
    fn send_packets(&self, server: &mut RenetServer);
}

impl Transport for Server<ClientManager> {
    fn update(&mut self, duration: Duration, server: &mut RenetServer) {
        match self.listen_socket.try_receive_event() {
            Some(event) => match event {
                steamworks::networking_types::ListenSocketEvent::Connected(event) => {
                    let client_id = server.get_free_id();
                    match event.remote().steam_id() {
                        Some(steam_id) => {
                            self.connections_steam_id.insert(steam_id, client_id);
                        }
                        _ => {}
                    }
                    server.add_connection(client_id);
                    self.connections.insert(client_id, event.take_connection());
                }
                steamworks::networking_types::ListenSocketEvent::Disconnected(event) => match event.remote().steam_id() {
                    Some(steam_id) => {
                        // TODO check if there is a better way
                        let client_id = self.connections_steam_id.get(&steam_id.clone()).unwrap().clone();
                        server.remove_connection(client_id);
                        self.connections_steam_id.remove(&steam_id);
                        self.connections.remove(&client_id);
                    }
                    None => {}
                },
                steamworks::networking_types::ListenSocketEvent::Connecting(event) => {
                    if server.connected_clients() < self.config.max_clients {
                        let _ = event.accept();
                    } else {
                        event.reject(steamworks::networking_types::NetConnectionEnd::AppGeneric, Some("Too many clients"));
                    }
                }
            },
            _ => {}
        }
    }

    fn send_packets(&self, server: &mut RenetServer) {}
}

impl Server<ClientManager> {
    pub fn new(client: &Client<ClientManager>, config: SteamTransportConfig) -> Self {
        //  TODO this must be called at the beginning of the application
        client.networking_utils().init_relay_network_access();
        let options: Vec<NetworkingConfigEntry> = Vec::new();
        let socket;
        match client.networking_sockets().create_listen_socket_p2p(0, options) {
            Ok(listen_socket) => {
                socket = listen_socket;
            }
            Err(handle) => {
                // TODO Logging instead of panic
                panic!("Failed to create listen socket: {:?}", handle);
            }
        }
        Self {
            listen_socket: socket,
            config,
            connections: HashMap::new(),
            connections_steam_id: HashMap::new(),
        }
    }
}

// Extensions for the RenetServer
trait AutoGeneratedId {
    fn get_free_id(&self) -> u64;
}

impl AutoGeneratedId for RenetServer {
    fn get_free_id(&self) -> u64 {
        let id = self.clients_id().len() as u64 + 1;
        id
    }
}
